name: Production Deployment

on:
  push:
    branches: [main]
    paths:
      - 'api/**'
      - 'web/**'
      - 'mobile/**'
      - 'docker-compose.yml'
  workflow_dispatch:

jobs:
  validate:
    name: Validate Code
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install API dependencies
        run: cd api && npm ci

      - name: Lint API
        run: cd api && npm run lint
        continue-on-error: true

      - name: Install Web dependencies
        run: cd web && npm ci

      - name: Lint Web
        run: cd web && npm run lint
        continue-on-error: true

      - name: Build Web
        run: cd web && npm run build:prod

  security:
    name: Security Checks
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

  deploy:
    name: Deploy to Production
    needs: [validate, security]
    runs-on: ubuntu-latest
    environment:
      name: production
    
    if: success()

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
        continue-on-error: true

      - name: Build and push API image
        uses: docker/build-push-action@v4
        with:
          context: api
          file: api/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:${{ github.sha }}
            ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:latest
            ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:prod

      - name: Build and push Web image
        uses: docker/build-push-action@v4
        with:
          context: web
          file: web/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:${{ github.sha }}
            ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:latest
            ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:prod

      - name: Deploy to production
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PROD_DEPLOY_HOST }} >> ~/.ssh/known_hosts
          
          ssh ${{ secrets.PROD_DEPLOY_USER }}@${{ secrets.PROD_DEPLOY_HOST }} << 'EOF'
          set -e
          
          cd ${{ secrets.PROD_DEPLOY_PATH }}
          
          # Backup current deployment
          docker-compose -f docker-compose.yml -f docker-compose.prod.yml exec -T postgres pg_dump -U postgres exitsaas > backup_$(date +%Y%m%d_%H%M%S).sql
          
          # Pull latest code
          git pull origin main
          
          # Update .env from secrets
          cp .env.production .env
          
          # Pull new images
          docker-compose -f docker-compose.yml -f docker-compose.prod.yml pull
          
          # Perform blue-green deployment
          docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps api web nginx
          
          # Wait for services to be healthy
          sleep 10
          
          # Run migrations
          docker-compose exec -T api npm run migrate
          
          # Health check
          for i in {1..30}; do
            if curl -f http://localhost/health; then
              echo "Health check passed!"
              break
            fi
            echo "Waiting for services to be healthy... ($i/30)"
            sleep 2
          done
          
          echo "Production deployment completed!"
          EOF
        env:
          PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
          PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
          PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Release v${{ github.run_number }}
          body: |
            Production deployment of commit ${{ github.sha }}
            
            **Images:**
            - API: ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:${{ github.sha }}
            - Web: ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:${{ github.sha }}
          draft: false
          prerelease: false

      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          text: 'Production Deployment - ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        continue-on-error: true

      - name: Alert if deployment failed
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: 'failure'
          text: 'ðŸš¨ Production Deployment FAILED!'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author
